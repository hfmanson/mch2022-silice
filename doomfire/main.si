// MIT license, see LICENSE_MIT in Silice repo root
// https://github.com/sylefeb/Silice
// @sylefeb 2022

// include the screen driver
$include('../common/lcd.si')
// PLL
import('../common/icebrkr_25.v')

// CPU declaration
riscv cpu_drawer(output uint32 rgb,        // send a pixel (RGB 24 bits)
                 output uint1  on_rgb,     // pulses high when CPU writes rgb
                 output uint32 leds,       // set on-board LEDs
                 output uint1  on_leds     // pulses high when CPU writes leds
                ) <
                  mem=8192,
                  core="ice-v-dual", // dual core please
                  ICEV_FAST_SHIFT=1, // fast shifts (barrel shifter)
                  O=3                // compile with -O3
                > {

  // =============== firmware in C language ===========================
/*
  #define FIRE_W 64
  #define FIRE_H 64

  //_ framebuffer
  unsigned char tbl[FIRE_W*FIRE_H + 8];
  //                                ^ padding

  //_ 32 xRGB entries ('fire' palette)
  unsigned char pal[] = {
    0,0x04,0x04,0x04, 0,0x1c,0x04,0x04, 0,0x2c,0x0c,0x04, 0,0x44,0x0c,0x04,
    0,0x54,0x14,0x04, 0,0x64,0x1c,0x04, 0,0x74,0x1c,0x04, 0,0x9c,0x2c,0x04,
    0,0xac,0x3c,0x04, 0,0xbc,0x44,0x04, 0,0xc4,0x44,0x04, 0,0xdc,0x54,0x04,
    0,0xdc,0x54,0x04, 0,0xd4,0x5c,0x04, 0,0xd4,0x5c,0x04, 0,0xd4,0x64,0x0c,
    0,0xcc,0x74,0x0c, 0,0xcc,0x7c,0x0c, 0,0xcc,0x84,0x14, 0,0xc4,0x84,0x14,
    0,0xc4,0x94,0x1c, 0,0xbc,0x9c,0x1c, 0,0xbc,0x9c,0x1c, 0,0xbc,0xa4,0x24,
    0,0xbc,0xa4,0x24, 0,0xbc,0xac,0x2c, 0,0xb4,0xac,0x2c, 0,0xb4,0xb4,0x2c,
    0,0xcc,0xcc,0x6c, 0,0xdc,0xdc,0x9c, 0,0xec,0xec,0xc4, 0,0xef,0xef,0xef};

  //_ draws fire onto the LCD
  void draw_fire()
  {
    while (1) {
      for (int u=0;u<FIRE_W;u++) {
        unsigned char *col = tbl + u;
        for (int v=0;v<FIRE_H;++v) {
          // palette lookup
          int clr  = ((*col)>>2)&31;
          col     += FIRE_W;
          int *ptr = (int*)(pal) + clr;
          // send to screen
          rgb(*ptr);
        }
      }
    }
  }

  //_ update the fire framebuffer
  void update_fire()
  {
    int rng  = 31421;  // random number generator seed
    while (1) {
      // move up
      unsigned char *below   = tbl;
      unsigned char *current = tbl + FIRE_W;
      for ( ; current < tbl + FIRE_W*FIRE_H ; ++current ) {
        int clr = 0;
        if ((*below) > 1) {
          clr = (*below)-(rng&1);
        }
        rng = (rng<<3) + ((rng>>3) ^ (int)current);
        *(current + (rng&3)) = clr; // NOTE: table padding avoids
                                    //       out of bounds access
        ++ below;
      }
      // keep the heat on
      unsigned char *ptr = tbl;
      for (int v=0;v<FIRE_W;v++) {
        rng = (rng<<5) + ((rng>>5) ^ (int)ptr);
        (*ptr++) = 120 + (rng&7);
      }
    }
  }
*/
  //_ C main
  void main() {
    /*
    if (core_id() == 0) {
      draw_fire();
    } else {
      update_fire();
    }
    */
    leds(3);
    for (int i=0;i<320;++i) {
    for (int j=0;j<240;++j) {
      rgb(i + (j<<8));
    }
    }
  }

  // =============== end of firmware ==================================
}

// now we are creating the hardware hosting the CPU
unit main(
  output uint8  leds,
  output uint8 lcd_d,
  output uint1 lcd_rs,
  output uint1 lcd_wr_n,
  output uint1 lcd_cs_n(0),
  output uint1 lcd_rst_n(1),
  input  uint1 lcd_mode,
  input  uint1 lcd_fmark,
  input  uint1 espspi_mosi,
  output uint1 espspi_miso,
  input  uint1 espspi_clk,
  input  uint1 espspi_cs_n,
  output uint1 espirq_n,
) <@clock_pll> {
  // ^^^^ design uses a PLL generated clock
  //                    vvv
  uint1 clock_pll = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock_pll,
  );

  // screen driver
  lcd_driver lcd(<:auto:>);
  //             ^^^^^^^^ use autobinding for the pins

  // instantiates our CPU as defined above
  cpu_drawer cpu;

  // interface for sending a full pixel
  uint16 pix_data(0);             // RGB 16bits to send
  uint2  pix_sending(2b00);       // sending? (11 => 01 => 00 done)

  always {
    uint1 can_send <:: pix_sending[0,1] & lcd.ready;

    leds          = cpu.leds;

    lcd.valid     = can_send;
    lcd.data      = pix_data[0,8];

    if (cpu.on_rgb) {
      // CPU requests RGB write
      // grab pixel data (convert RGB 24 bits to 16 bits)
      uint5  r     <: cpu.rgb[ 3, 5];
      uint6  g     <: cpu.rgb[10, 6];
      uint5  b     <: cpu.rgb[19, 5];
      uint16 clr   <: {g[0,3],r,b,g[3,3]};
      pix_data    = {g[0,3],r,b,g[3,3]};
      // initiate sending
      pix_sending = 2b11;
    } else {
      // if we can send, shift to next
      pix_data    = can_send ? pix_data>>8    : pix_data;
      pix_sending = can_send ? pix_sending>>1 : pix_sending;
    }
  }

}
