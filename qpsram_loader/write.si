// @sylefeb 2020
// https://github.com/sylefeb/Silice
// MIT license, see LICENSE_MIT in Silice repo root

$include('../common/qpsram2x.si')

$$if ICE40 then
import('../../Silice/projects/common/plls/icebrkr_25.v')
$$end

$$uart_in_clock_freq_mhz = 25
$include('../../Silice/projects/common/uart.si')

unit main(
  output uint3 leds,
  input  uint1 uart_rx,
  output uint1 uart_tx,
  inout  uint1 ram_io0,
  inout  uint1 ram_io1,
  inout  uint1 ram_io2,
  inout  uint1 ram_io3,
  output uint1 ram_clk,
  output uint1 ram_csn,
)
// clocking (pll) and reset
$$if ICE40 then
<@clock_pll> {
  uint1 clock_pll = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock_pll,
  );
$$else
{
$$end

  // QPSRAM RAM
  qpsram_ram ram(
    ram_csn  :> ram_csn,
    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,
    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,
    ram_io3 <:> ram_io3,
  );

  // UART receiver
  uart_in ui;
  uart_receiver urecv(io <:> ui,uart_rx <: uart_rx);

  uart_out uo;
  uart_sender usend(
    io      <:> uo,
    uart_tx :>  uart_tx
  );

  uint1  enabled(0);
  uint24 addr(0);
  uint32 blip(0);

  always {

    ram.in_ready = 0; // maintain low, pulse high to read/write
    ram.addr     = addr;
    ram.wenable  = 1; // we write

    leds         = blip;
    blip         = blip >> 1;

    if (ui.data_out_ready) {
      ram.in_ready = enabled;
      ram.wdata    = ui.data_out;
      addr         = enabled ? (addr + 1) : addr;
      enabled      = enabled | (ui.data_out == 8hAA);
      blip         = enabled ? 32hffffffff : 0;
    }

  }

}
