// @sylefeb 2020
// https://github.com/sylefeb/Silice
// MIT license, see LICENSE_MIT in Silice repo root

/*

Simple quad PSRAM test.

Writes 256 bytes to PSRAM, reads them back and sends them through UART

*/


// QPSRAM driver
$include('../common/qpsram2x.si')
// 25 MHz clock
import('../common/icebrkr_25.v')
// import UART
$$uart_in_clock_freq_mhz = 25
$include('../common/uart.si')

unit main(
  output uint3 leds,
  input  uint1 uart_rx,
  output uint1 uart_tx,
  inout  uint1 ram_io0,
  inout  uint1 ram_io1,
  inout  uint1 ram_io2,
  inout  uint1 ram_io3,
  output uint1 ram_clk,
  output uint1 ram_csn,
) <@clock_pll> {
  // ^^^^ design uses PLL generated clock
  //                  vvv
  uint1 clock_pll = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> clock_pll,
  );
  // instantiates QPSRAM
  qpsram_ram ram(
    ram_csn  :> ram_csn,
    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,
    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,
    ram_io3 <:> ram_io3,
  );
  // UART sender
  uart_out uo;
  uart_sender usend(
    io      <:> uo,
    uart_tx :>  uart_tx
  );

  ram.in_ready     := 0; // maintain low, pulse high to read/write
  uo.data_in_ready := 0; // maintain low, pulse high to send

  algorithm {

    uint16 n = 0;

    // write some
    n = 0;
    ram.wenable  = 1;
    while (~n[8,1]) {
      ram.addr     = n;
      ram.wdata    = {4hA,n[0,4]};
      ram.in_ready = 1;
      while (ram.busy) {}
      n = n + 1;
    }

    // read some
    n = 0;
    ram.wenable  = 0;
    while (~n[8,1]) {
      ram.addr     = n;
      ram.in_ready = 1;
      while (ram.busy) {}
      uo.data_in       = ram.rdata;
      uo.data_in_ready = 1;
      while (uo.busy) {}
      n = n + 1;
    }

  }

}
